#ifndef LEPP2_SPLIT_APPROXIMATOR_H__
#define LEPP2_SPLIT_APPROXIMATOR_H__
#include "lepp2/ObjectApproximator.hpp"
#include "lepp2/models/ObjectModel.h"

#include <deque>
#include <pcl/common/pca.h>
#include <pcl/common/common.h>

namespace lepp {

/**
 * An approximator implementation that will generate an approximation by
 * splitting the given object into multiple parts. Each part approximation is
 * generated by delegating to a wrapped `ObjectApproximator` instance, allowing
 * clients to vary the algorithm used for approximations, while keeping the
 * logic of incrementally splitting up the object.
 */
template<class PointT>
class SplitObjectApproximator : public ObjectApproximator<PointT> {
public:
  /**
   * Create a new `SplitObjectApproximator` that will approximate each part by
   * using the given approximator instance.
   */
  SplitObjectApproximator(boost::shared_ptr<ObjectApproximator> approx)
      : approximator_(approx) {}
  /**
   * `ObjectApproximator` interface method.
   */
  boost::shared_ptr<CompositeModel> approximate(
      const typename pcl::PointCloud<PointT>::ConstPtr& point_cloud);
private:
  /**
   * Splits the given point_cloud into two parts and places them in the
   * ``first`` and ``second`` PointCloud references.
   */
  void splitCloud(
      const typename pcl::PointCloud<PointT>::ConstPtr& point_cloud,
      pcl::PointCloud<PointT>& first,
      pcl::PointCloud<PointT>& second);

  /**
   * Returns a point representing an estimation of the position of the center
   * of mass for the given point cloud.
   */
  Eigen::Vector3f estimateMassCenter(
      const typename pcl::PointCloud<PointT>::ConstPtr& point_cloud);

  /**
   * An `ObjectApproximator` used to generate approximations for object parts.
   */
  boost::shared_ptr<ObjectApproximator> approximator_;
};

template<class PointT>
boost::shared_ptr<CompositeModel> SplitObjectApproximator<PointT>::approximate(
    const typename pcl::PointCloud<PointT>::ConstPtr& point_cloud) {
  boost::shared_ptr<CompositeModel> approx(new CompositeModel);
  typedef typename pcl::PointCloud<PointT>::ConstPtr PointCloudConstPtr;
  typedef typename pcl::PointCloud<PointT>::Ptr PointCloudPtr;
  std::deque<PointCloudConstPtr> queue;
  queue.push_back(point_cloud);

  int iteration = 0;
  while (!queue.empty()) {
    PointCloudConstPtr current_cloud = queue[0];
    queue.pop_front();

    // Delegates to the wrapped approximator for each part's approximation.
    ObjectModelPtr model = approximator_->approximate(current_cloud);
    // TODO Decide whether the model fits well enough for the current cloud.
    // For now we fix the number of split iterations.
    if (iteration == 0) {
      // The approximation should be improved. Try doing it for the split clouds
      PointCloudPtr first(new pcl::PointCloud<PointT>());
      PointCloudPtr second(new pcl::PointCloud<PointT>());
      splitCloud(current_cloud, *first, *second);
      queue.push_back(first);
      queue.push_back(second);
    } else {
      // Keep the approximation
      approx->addModel(model);
    }
    ++iteration;
  }

  return approx;
}

template<class PointT>
void SplitObjectApproximator<PointT>::splitCloud(
    const typename pcl::PointCloud<PointT>::ConstPtr& point_cloud,
    pcl::PointCloud<PointT>& first,
    pcl::PointCloud<PointT>& second) {
  // Compute PCA for the input cloud
  pcl::PCA<PointT> pca;
  pca.setInputCloud(point_cloud);
  Eigen::Vector3f eigenvalues = pca.getEigenValues();
  Eigen::Matrix3f eigenvectors = pca.getEigenVectors();

  Eigen::Vector3d main_pca_axis = eigenvectors.col(0).cast<double>();

  // Compute the centroid
  Eigen::Vector4d centroid;
  pcl::compute3DCentroid(*point_cloud, centroid);

  /// The plane equation
  double d = (-1) * (
      centroid[0] * main_pca_axis[0] +
      centroid[1] * main_pca_axis[1] +
      centroid[2] * main_pca_axis[2]
  );

  // Now divide the input cloud into two clusters based on the splitting plane
  size_t const sz = point_cloud->size();
  for (size_t i = 0; i < sz; ++i) {
    // Boost the precision of the points we are dealing with to make the
    // calculation more precise.
    PointT const& original_point = (*point_cloud)[i];
    Eigen::Vector3f const vector_point = original_point.getVector3fMap();
    Eigen::Vector3d const point = vector_point.cast<double>();
    // Decide on which side of the plane the current point is and add it to the
    // appropriate partition.
    if (point.dot(main_pca_axis) + d < 0.) {
      first.push_back(original_point);
    } else {
      second.push_back(original_point);
    }
  }
}


#endif
